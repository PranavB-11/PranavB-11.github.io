<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 3: Image Warping and Mosaicing</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

    <nav>
        <ul>
            <li><a href="../index.html" class="back-arrow">&larr;</a></li>
            <li><a href="../Project 0/index.html" class="project-link">Project 0</a></li>
            <li><a href="../Project 1/index.html" class="project-link">Project 1</a></li>
            <li><a href="../Project 2/index.html" class="project-link">Project 2</a></li>
            <li><a href="index.html" class="project-link active">Project 3</a></li>
        </ul>
    </nav>

    <div class="main-container" style="padding-top: 80px; padding-bottom: 10px;">
        <h1 style="font-size: 3.5rem;">Project 3: Image Warping and Mosaicing</h1>
    </div>

    <div class="project-content" style="padding-top: 20px;">

        <div class="section">
            <h2>Part A.1: Shooting the Pictures</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: center; line-height: 1.6;">
                <p>
                    These are the images I will be warping in Part A.4
                </p>
            </div>
            
            <div class="image-gallery" style="display: flex; flex-direction: column; align-items: center; gap: 40px; margin-bottom: 40px;">
                <figure style="text-align: center; max-width: 70%;">
                    <img src="output_images/sunset1.png" alt="Sunset facing West" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">
                        Pictures of sunset facing West
                    </figcaption>
                </figure>
                
                <figure style="text-align: center; max-width: 70%;">
                    <img src="output_images/sunset2.png" alt="Berkeley facing North" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">
                        Pictures of Berkeley facing North
                    </figcaption>
                </figure>

                <figure style="text-align: center; max-width: 70%;">
                    <img src="output_images/building.png" alt="Apartments in Berkeley" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">
                        Some apartments in Berkeley
                    </figcaption>
                </figure>
            </div>
        </div>

        <div class="section">
            <h2>Part A.2: Recovering Homographies</h2>

            <h3 style="text-align: center; font-weight: 500; margin-top: 40px;">Correspondence Set 1</h3>
            <figure style="text-align: center; max-width: 80%; margin: 20px auto;">
                <img src="output_images/corresp1.png" alt="Correspondence visualization 1" style="max-width: 100%; height: auto; border-radius: 8px;">
            </figure>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: center; line-height: 1.6;">
                <p>The system being solved is \(Ah = b\), where:</p>
                <ul style="display: inline-block; text-align: left;">
                    <li>\(A\) is a (16, 8) matrix based on the source points.</li>
                    <li>\(b\) is a (16, 1) vector based on the destination points.</li>
                    <li>\(h\) is the \(h = [h_{11}, h_{12}, ..., h_{32}]^T\) vector of unknowns.</li>
                </ul>
                <p><strong>Matrix A (first 4 rows):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[ 1234.   667.     1.     0.     0.     0. -869970. -470235.]
 [    0.     0.     0.  1234.   667.     1. -797164. -430882.]
 [ 1238.   909.     1.     0.     0.     0. -860410. -631755.]
 [    0.     0.     0.  1238.   909.     1. -1099344. -807192.]]</code></pre>
                <p><strong>Vector b (first 4 rows):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[705.]
 [646.]
 [695.]
 [888.]]</code></pre>
                <p><strong>Recovered Homography Matrix (H):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[    2.656962    -0.102009 -1791.989562]
 [    0.688098     2.026906  -904.011658]
 [    0.000824    -0.000010     1.000000]]</code></pre>
            </div>

            <hr style="margin: 60px auto; width: 80%;">

            <h3 style="text-align: center; font-weight: 500; margin-top: 40px;">Correspondence Set 2</h3>
            <figure style="text-align: center; max-width: 80%; margin: 20px auto;">
                <img src="output_images/corresp2.png" alt="Correspondence visualization 2" style="max-width: 100%; height: auto; border-radius: 8px;">
            </figure>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: center; line-height: 1.6;">
                <p>The system being solved is \(Ah = b\), where:</p>
                <ul style="display: inline-block; text-align: left;">
                    <li>\(A\) is a (26, 8) matrix based on the source points.</li>
                    <li>\(b\) is a (26, 1) vector based on the destination points.</li>
                    <li>\(h\) is the \(h = [h_{11}, h_{12}, ..., h_{32}]^T\) vector of unknowns.</li>
                </ul>
                <p><strong>Matrix A (first 4 rows):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[  885.   694.     1.     0.     0.     0. -296475. -232490.]
 [    0.     0.     0.   885.   694.     1. -554010. -434444.]
 [  677.   815.     1.     0.     0.     0.  -20987.  -25265.]
 [    0.     0.     0.   677.   815.     1. -521290. -627550.]]</code></pre>
                <p><strong>Vector b (first 4 rows):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[335.]
 [626.]
 [ 31.]
 [770.]]</code></pre>
                <p><strong>Recovered Homography Matrix (H):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[    2.598607     0.096351 -1783.270998]
 [    0.557153     2.171179  -901.432678]
 [    0.000742     0.000142     1.000000]]</code></pre>
            </div>

            <hr style="margin: 60px auto; width: 80%;">

            <h3 style="text-align: center; font-weight: 500; margin-top: 40px;">Correspondence Set 3</h3>
            <figure style="text-align: center; max-width: 80%; margin: 20px auto;">
                <img src="output_images/corresp3.png" alt="Correspondence visualization 3" style="max-width: 100%; height: auto; border-radius: 8px;">
            </figure>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: center; line-height: 1.6;">
                <p>The system being solved is \(Ah = b\), where:</p>
                <ul style="display: inline-block; text-align: left;">
                    <li>\(A\) is a (32, 8) matrix based on the source points.</li>
                    <li>\(b\) is a (32, 1) vector based on the destination points.</li>
                    <li>\(h\) is the \(h = [h_{11}, h_{12}, ..., h_{32}]^T\) vector of unknowns.</li>
                </ul>
                <p><strong>Matrix A (first 4 rows):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[ 1693.   782.     1.     0.     0.     0. -2026521.  -936054.]
 [    0.     0.     0.  1693.   782.     1. -1276522.  -589628.]
 [ 1477.   823.     1.     0.     0.     0. -1509494.  -841106.]
 [    0.     0.     0.  1477.   823.     1. -1166830.  -650170.]]</code></pre>
                <p><strong>Vector b (first 4 rows):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[1197.]
 [ 754.]
 [1022.]
 [ 790.]]</code></pre>
                <p><strong>Recovered Homography Matrix (H):</strong></p>
                <pre><code style="display: inline-block; text-align: left;">[[    2.088005     0.036937 -1270.782966]
 [    0.398799     1.667506  -533.298936]
 [    0.000535     0.000014     1.000000]]</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>Part A.3: Image Warping and Rectification</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: center; line-height: 1.6;">
                <p>
                    Nearest neighbor interpolation has a generally low, blocky, pixelated quality and has jagged edges - aliasing. It doesn't create any new colors, just samples existing ones. That being said, it is very fast, from the images I sampled, it was around 4x quicker than Bilinear interpolation. Bilinear interpolation was high quality, mostly since it calculates a weighted average of the four closest pixels' colors, creating a much smoother and natural looking image. The edges are also properly anti-aliased, eliminated that jagged look. It is slower as a result, since four memory lookups are required to get the colors of the neighboring pixels + several floating point multiplications.
                </p>
            </div>
            
            <figure style="text-align: center; max-width: 80%; margin: 20px auto;">
                <img src="output_images/rectify1.png" alt="First rectification comparison" style="max-width: 100%; height: auto; border-radius: 8px;">
                <figcaption style="margin-top: 10px; font-style: italic; color: #555;">The aliasing in the nearest neighbor interpolation is very visible here - the "Rainier" text is pixelated. While both images are sort of blurry, the Bilinear output is much smoother.</figcaption>
            </figure>

            <hr style="margin: 60px auto; width: 80%;">

            <figure style="text-align: center; max-width: 80%; margin: 20px auto 40px auto;">
                <img src="output_images/rectify2.png" alt="Second rectification comparison" style="max-width: 100%; height: auto; border-radius: 8px;">
                <figcaption style="margin-top: 10px; font-style: italic; color: #555;">It's hard to tell the difference between the two interpolations here, but if you look closely, the "Jaws" text on the bilinear output has a much softer red tint to it from the weighted averaging, giving it a more realistic look in my opinion. Also, the shark is quite blocky in the nearest neighbor output.</figcaption>
            </figure>
        </div>
        
        <div class="section">
            <h2>Part A.4: Image Mosaicing</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: left; line-height: 1.6;">
                <p>
                    The procedure I implemented follows these steps:
                    First, I established a common coordinate system by selecting one image as the stationary "reference frame". In this case, the right-hand image would be the reference. Using a set of manually selected corresponding points between the left and right images, a 3x3 homography matrix is computed. This matrix describes the precise projective transformation needed to map the left image onto the coordinate plane of the reference (right) image. Then the left image is warped using this homography with my bilinear warping function, which automatically calculates the new bounds for the transformed image. 
                </p>
                <p>
                    Next, to avoid a hard edge where images overlap, a blending technique called linear feathering is used. It is a form of weighted average where the final color in the overlapping area is a mix of the colors from both images. This is achieved by creating alpha masks that act as weights. The mask for each image is fully opaque (weight of 1.0) on its non-overlapping side and linearly fades to a fully transparent (weight of 0.0) on the overlapping side.
                </p>
                <p>
                    Finally, the mosaic is created - a new canvas is formed that is big enough to contain both the warped (left) and reference (right) image. The colors from each image, multiplied by their respective feathering mask weights, are accumulated onto this canvas. The weights themselves are accumulated on a separate map. By dividing the final color values by the final weight values for each pixel, we get a smoothly blended average color throughout the image, making the transition seamless.
                </p>
            </div>
            
            <div class="image-gallery" style="display: flex; flex-direction: column; align-items: center; gap: 20px; margin-top: 40px; margin-bottom: 40px;">

                <figure style="text-align: center; max-width: 95%;">
                    <img src="output_images/source1.png" alt="Source images for Mosaic 1" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Source Images for Mosaic 1</figcaption>
                </figure>
                <figure style="text-align: center; max-width: 95%; margin-bottom: 40px;">
                    <img src="output_images/mos1.png" alt="Resulting Mosaic 1" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Resulting Mosaic 1</figcaption>
                </figure>

                <hr style="width: 80%;">

                <figure style="text-align: center; max-width: 95%; margin-top: 40px;">
                    <img src="output_images/source2.png" alt="Source images for Mosaic 2" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Source Images for Mosaic 2</figcaption>
                </figure>
                <figure style="text-align: center; max-width: 95%; margin-bottom: 40px;">
                    <img src="output_images/mos2.png" alt="Resulting Mosaic 2" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Resulting Mosaic 2</figcaption>
                </figure>

                <hr style="width: 80%;">

                <figure style="text-align: center; max-width: 95%; margin-top: 40px;">
                    <img src="output_images/source3.png" alt="Source images for Mosaic 3" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Source Images for Mosaic 3</figcaption>
                </figure>
                <figure style="text-align: center; max-width: 95%;">
                    <img src="output_images/mos3.png" alt="Resulting Mosaic 3" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Resulting Mosaic 3</figcaption>
                </figure>
            </div>
        </div>

        <div class="section">
            <h2>Part B.1: Harris Corner Detection & ANMS</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: left; line-height: 1.6;">
                <p>
                    The Harris Corner Detector finds features by identifying areas in the image with strong intensity changes in multiple directions. However, as the first image shows, this produces thousands of corners that are heavily clustered in high texture regions. To solve this, we use ANMS, which selects a fixed number of corners that are well-distributed spatially by calculating a suppression radius (the distance to the nearest corner that is significantly stronger). By selecting corners with the largest suppression radii, we choose points that are local maxima over a large area.
                </p>
            </div>
            <div class="image-gallery" style="display: flex; justify-content: center; gap: 40px; margin-bottom: 40px;">
                <figure style="text-align: center; max-width: 45%;">
                    <img src="output_images2/cornersnoanms.png" alt="Detected Harris Corners before ANMS" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">
                        All of the detected harris corners
                    </figcaption>
                </figure>
                <figure style="text-align: center; max-width: 45%;">
                    <img src="output_images2/cornerswithanms.png" alt="Corners after ANMS" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">
                        500 of the 'best' harris corners detected in the image
                    </figcaption>
                </figure>
            </div>
        </div>

        <div class="section">
            <h2>Part B.2: Feature Descriptor Extraction</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: left; line-height: 1.6;">
                <p>
                    Now we need to find feature descriptors that allow us to compare points and find potential matches between different images. Per the paper, these descriptors are a large 40x40 window extracted from a blurred version of the image around each corner, which is then sub-sampled every 5 pixels to create a 8x8 patch. This low-frequency sampling makes the descriptor robust to small errors in the corner's location. Finally, this patch is flattened into a 64 element vector and bias/gain normalized by subtracting its mean and dividing by its std dev. This makes the descriptor invariant to changes in lighting. The results appear blurry and abstract, but they capture the general low-frequency structure, rather than fine, unstable details.
                </p>
            </div>
            <figure style="text-align: center; max-width: 60%; margin: 20px auto;">
                <img src="output_images2/descriptors.png" alt="Extracted Feature Descriptors" style="max-width: 100%; height: auto; border-radius: 8px;">
                <figcaption style="margin-top: 10px; font-style: italic; color: #555;">A sample of extracted and normalized 8x8 feature descriptors.</figcaption>
            </figure>
        </div>

        <div class="section">
            <h2>Part B.3: Feature Matching</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: left; line-height: 1.6;">
                <p>
                    With descriptors extracted for both images, now we find correspondences. We use both 1-NN and 2-NN because simply taking the best match for every feature may lead to outliers because many image patches aren't unique and may be coincidentally similar to other descriptors. For a reliable match, we use Lowe's proposition described in the paper: the distance to the 1-NN should be significantly smaller than the distance to the 2-NN. This is implemented by computing the ration of the squared distances and only accepting matches where the ratio is below a threshold of 0.5. This gives us a good set of matches for RANSAC.
                </p>
            </div>
            <figure style="text-align: center; max-width: 95%; margin: 20px auto;">
                <img src="output_images2/matching.png" alt="Feature matches between two images" style="max-width: 100%; height: auto; border-radius: 8px;">
                <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Feature matches found using Lowe's ratio test.</figcaption>
            </figure>
        </div>S

        <div class="section">
            <h2>Part B.4: RANSAC and Automatic Mosaics</h2>
            <div style="max-width: 960px; margin: 0 auto 40px auto; text-align: left; line-height: 1.6;">
                <p>
                    Finally, we use our feature matches to compute a homography and stitch the images. However, the set of matches from the previous part may still contain outliers. To combat this, we implement RANSAC which iteratively finds the best homography by building a consensus from the inliers (good matches) while ignoring outliers. It first randomly selects a 4-point sample from the list of features matches, then computes a homography H, scores this H on all of the matches by counting how many points when transformed by H land close to their corresponding match in the other image (these points are the inliers), then at the end, pick the homography that has the largest set of inliers, re-computing a new homography using all the points from this set.
                </p>
                <p>
                    The difference in quality between the manual and automatic mosaics is subtle for these images, but if you look at the correspondences that I manually selected, there is a slight distortion at those points due to human error. This occurs even with careful selection. If I rushed any of those correspondences, then the final output would be very distorted and blurry. Also, manual mosaics are generated from a homography computed using a very small number of points, which is extremely sensitive to errors. This is exactly where RANSAC thrives, since it finds the largest subset of points that all agree on a single transformation, discarding incorrect matches. This is why the automatic mosaics are sharp and are free of the visual artifacts present in the manual versions.
                </p>
            </div>

            <div class="image-gallery" style="margin-top: 40px; margin-bottom: 40px;">
                <h3 style="text-align: center; font-weight: 500; margin-bottom: 20px;">Manual Mosaics</h3>
                <div style="display: flex; justify-content: center; align-items: flex-start; gap: 15px;">
                    <figure style="text-align: center; max-width: 32%;">
                        <img src="output_images2/manualsunset1.png" alt="Manual Mosaic 1" style="max-width: 100%; height: auto; border-radius: 8px;">
                    </figure>
                    <figure style="text-align: center; max-width: 32%;">
                        <img src="output_images2/manualsunset2.png" alt="Manual Mosaic 2" style="max-width: 100%; height: auto; border-radius: 8px;">
                    </figure>
                    <figure style="text-align: center; max-width: 32%;">
                        <img src="output_images2/manualbuidling.png" alt="Manual Mosaic 3" style="max-width: 100%; height: auto; border-radius: 8px;">
                    </figure>
                </div>
                 <p style="text-align: center; font-style: italic; color: #555; margin-top: 15px;">
                    Mosaics created using a naive homography from a few random points.
                </p>
            </div>

            <hr style="width: 80%; margin: 60px auto;">

            <div class="image-gallery" style="display: flex; flex-direction: column; align-items: center; gap: 40px; margin-top: 40px;">
                <h3 style="text-align: center; font-weight: 500; margin-bottom: 20px;">Automatic Mosaics</h3>
                <figure style="text-align: center; max-width: 95%;">
                    <img src="output_images2/autosunset1.png" alt="Automatic Mosaic 1" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Automatic Sunset Mosaic 1</figcaption>
                </figure>
                <figure style="text-align: center; max-width: 95%;">
                    <img src="output_images2/autosunset2.png" alt="Automatic Mosaic 2" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Automatic Sunset Mosaic 2</figcaption>
                </figure>
                <figure style="text-align: center; max-width: 95%;">
                    <img src="output_images2/autobuilding.png" alt="Automatic Mosaic 3" style="max-width: 100%; height: auto; border-radius: 8px;">
                    <figcaption style="margin-top: 10px; font-style: italic; color: #555;">Automatic Building Mosaic</figcaption>
                </figure>
            </div>
        </div>

    </div>

</body>
</html>